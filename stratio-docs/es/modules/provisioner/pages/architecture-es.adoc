:toc: left
:toclevels: 4
// Images dir path for AsciidocFX:
//:imagesdir: stratio-docs/es/modules/provisioner/assets/images
// Images dir path for GitHub:
:imagesdir: /stratio-docs/es/modules/provisioner/assets/images
// Antora does not require the `imagesdir` directive

= _Stratio KEOS_ en clouds: Arquitectura

Versión: 0.1.0

== Arquitectura de referencia

image::EKS_reference-architecture.png[]

=== Objetos del _cloud provider_

===== [EKS]

En un despliegue *por defecto*, se crean los siguientes objetos en AWS (en [silver]#gris# los objetos opcionales que dependerán de lo especificado en el descriptor del cluster):

* [silver]#1 VPC.#
* [silver]#6 subnets con sus respectivas tablas de rutas.#
** [silver]#3 subnets públicas (una por AZ).#
** [silver]#3 subnets privadas (también una por AZ).#
* [silver]#1 NAT gateway por cada subnet pública.#
* [silver]#1 Internet gateway para la VPC.#
* [silver]#1 ruta por defecto en la tabla de rutas de cada subnets privada para salir a internet a través de los NAT gateways.#
* [silver]#1 ruta por defecto en la tabla de rutas de cada subnets pública para salir a internet a través del Internet Gateway.#

* 1 IAM Policy para los nodos del cluster (nodes.cluster-api-provider-aws.sigs.k8s.io)
* 1 IAM Role para los nodos del cluster (nodes.cluster-api-provider-aws.sigs.k8s.io)
* 1 cluster de Elastic Kubernetes Service (EKS) con add-ons para EBS y CNI, logging (si se ha especificado), y un OIDC provider.
** 2 Security Groups de EKS para el Control Plane y los nodos Worker.
** 1 IAM Role con la policy AmazonEKSClusterPolicy.

* VMs para Workers (según descriptor del cluster y autoescalado).
** 1 Volúmen EBS por VM.
* 1 Load Balancer tipo Network para exposición de servicios.
** 1 Listener por puerto para cada Service tipo LB.
* Vólumen EBS para cada PV.

===== [GCP]

* 1 Load Balancer tipo SSL/TCP para el APIserver.
* 1 HealthCheck para el Unmanage Instance Group.
* 1 CloudNat Asociando VPC
* 1 Cloud Router
* Reglas de firewall
* 1 Unmanage Instance Group para el control-plane.

* 1/3 VMs para el control-plane (según descriptor del cluster).
** 1 Volúmen EBS por VM.
* VMs para Workers (según descriptor del cluster y autoescalado).
** 1 Volúmen EBS por VM.
* 1 Load Balancer L4 para exposición de servicios.
** 1 Listener por puerto para cada Service tipo LB.
* Vólumen EBS para cada PV.

=== Seguridad

==== Acceso a IMDS en EKS

Dado que los Pods ejecutados en un nodo de AWS pueden impersonar al nodo donde se ejecutan simplemente interactuando con IMDS, se utiliza una política de red global (GlobalNetworkPolicy de Calico) para impedir el acceso a todos los Pods del cluster.

A su vez, se habilita el OIDC provider de EKS para permitir el uso de IAM roles para Service Accounts, asegurando el uso de políticas IAM con mínimos privilegios.

==== APIserver endpoint access

===== [EKS]

Durante la creación del cluster de EKS, se crea un endpoint para el APIserver que se utilizará para el acceso al cluster desde el instalador y operaciones del ciclo de vida.

Este endpoint se publica a internet, y su acceso se restringe con una combinación de reglas de AWS Identity and Access Management (IAM), y el Role Based Access Control (RBAC) nativo de Kubernetes.

===== [GCP]

Para la exposición del APIserver, se crea un Load Balancer con nombre <cluster_id>-apiserver y puerto 443 accesible por red pública (la IP pública asignada es la misma que se configura en el Kubeconfig), y un instance groups por AZ (1 o 3, según configuración de HA) con el nodo de control-plane correspondiente.

El HealthCheck del servicio se hace por SSL, pero se recomienda cambiar a HTTPS con path /healthz.

=== Storage

==== Nodos

A nivel de Storage, se monta un único disco root del que podemos definir su tipo, tamaño y encriptación.

_Ejemplo:_

----
type: gcp2
size: 384Gi
encrypted: true
----

Estos discos se crean en la provisión inicial de los nodos workers, por lo que estos datos se pasan como parámetros del descriptor.

==== StorageClass

Por defecto, el cluster disponibiliza una StorageClass ("gp2" en AWS y "csi-gcp-pd" en GCP) para disco de bloques con filesystem ext4. Esta StorageClass se crea con _reclaimPolicy: Delete_ y _volumeBindingMode: WaitForFirstConsumer_, esto es, que el disco se creará en el momento que un Pod consuma el PersistentVolumeClaim correspondiente, y se eliminará al borrar el PersistentVolume.

Se deberá tener en cuenta que los PersistentVolumes creados a partir de esta StorageClass tendrán afinidad con la zona donde se han consumido.

