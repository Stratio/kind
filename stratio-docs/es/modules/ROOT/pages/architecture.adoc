= Arquitectura

Arquitectura de referencia

image::eks-reference-architecture.png[]

== Objetos del proveedor del _Cloud_

En un *despliegue por defecto*, se crean los siguientes objetos en cada _cloud provider_ (en [silver]#gris# los objetos opcionales que dependerán de lo especificado en el descriptor del _cluster_):

=== EKS

* 1 _cluster_ de Elastic Kubernetes Service (EKS) con _add-ons_ para EBS y CNI, _logging_ (si se ha especificado) y un proveedor OIDC.
** 2 _Security Groups_ de EKS para el _control-plane_ y los nodos _Worker_.
** 1 rol de IAM con la política AmazonEKSClusterPolicy.

* [silver]#1 VPC.#

* [silver]#6 _subnets_ con sus respectivas tablas de rutas.#
** [silver]#3 _subnets_ públicas (una por AZ).#
** [silver]#3 _subnets_ privadas (también una por AZ).#

* [silver]#1 _NAT gateway_ por cada _subnet_ pública.#
* [silver]#1 _Internet gateway_ para la VPC.#
* [silver]#1 ruta por defecto en la tabla de rutas de cada _subnet_ privada para salir a internet a través de los NAT gateways.#
* [silver]#1 ruta por defecto en la tabla de rutas de cada _subnet_ pública para salir a internet a través del Internet Gateway.#
* 1 política de IAM para los nodos del _cluster_ (_nodes.cluster-api-provider-aws.sigs.k8s.io_).
* 1 rol de IAM para los nodos del _cluster_ (_nodes.cluster-api-provider-aws.sigs.k8s.io_).

* VMs para _Workers_ (según descriptor del _cluster_ y autoescalado).
** 1 Volumen EBS para cada volumen persistente.

* 1 Balanceador de carga tipo _Network_ para la exposición de _Services_ tipo Load Balancer.
** 1 _Listener_ por puerto para cada _Service_.

* Volumen EBS para cada volumen persistente.

=== GCP

* 1 Balanceador de carga tipo SSL/TCP para el APIserver.
* 1 _Health Check_ para el _Unmanage Instance Group_.
* 1 _CloudNat_ Asociando VPC.
* 1 _Cloud Router_.
* Reglas de _firewall_.
* 1 _Unmanage Instance Group_ para el _control-plane_.

* 1/3 VMs para el _control-plane_ (según descriptor del _cluster_).
** 1 Persistent disk por VM.

* VMs para _workers_ (según el descriptor del _cluster_ y autoescalado).
** 1 Persistent disk por VM.

* 1 Balanceador de carga L4 para la exposición de _Services_ tipo Load Balancer.
** 1 _Listener_ por puerto para cada _Service_.

* Persistent disk para cada volumen persistente.

=== Azure no-gestionado

* [silver]#1 Resource group.#
* 1 Virtual Network.
* 1 Route table para workers.
* 1 NAT gateway para workers.
* 2 Public IP address (apiserver y NATgw de workers).
* 2 Network Security Group (control-plane y workers).
* 1 LB público.

* 1/3 VMs para el _control-plane_ (según descriptor del _cluster_).
** 1 Disco de bloque por VM.
** 1 Network interface por VM.

* VMs para _workers_ (según el descriptor del _cluster_ y autoescalado).
** 1 Disco de bloque por VM.
** 1 Network interface por VM.

* 1 Balanceador de carga para la exposición de _Services_ tipo Load Balancer.
** 1 Public IP address para cada _service_.
** 1 Frontend IP config para cada _service_.
** 1 Health probe para cada _service_.
** 1 LB rule para cada _service_.

* Disco de bloque para cada volumen persistente.

=== AKS

* 1 _cluster_ de Azure Kubernetes Service (AKS).

* 2 Resource groups (para AKS y workers).
* 2 Virtual Network (para AKS y workers).
* 1 Public IP address (para salida de workers).
* 1 Network Security Group para workers.
* 1 Managed Identity.

* VM Scale Sets para _workers_ (según el descriptor del _cluster_).

* 1 Balanceador de carga para la exposición de _Services_ tipo Load Balancer.
** 1 Public IP address para cada _service_.
** 1 Frontend IP config para cada _service_.
** 1 Health probe para cada _service_.
** 1 LB rule para cada _service_.

* Disco de bloque para cada volumen persistente.

== Seguridad

=== Acceso a IMDS (para EKS y GCP)

Dado que los _pods_ pueden impersonar al nodo donde se ejecutan simplemente interactuando con IMDS, se utiliza una política de red global (_GlobalNetworkPolicy_ de Calico) para impedirles el acceso a todos los _pods_ del _cluster_ que no sean parte de _Stratio KEOS_.

A su vez, en EKS se habilita el proveedor OIDC para permitir el uso de roles de IAM para _Service Accounts_, asegurando el uso de políticas IAM con mínimos privilegios.

=== Acceso al _endpoint_ del APIserver

==== EKS

Durante la creación del _cluster_ de EKS, se crea un _endpoint_ para el APIserver que se utilizará para el acceso al _cluster_ desde el instalador y operaciones del ciclo de vida.

Este _endpoint_ se publica a internet, y su acceso se restringe con una combinación de reglas de AWS Identity and Access Management (IAM) y el Role Based Access Control (RBAC) nativo de Kubernetes.

==== GCP

Para la exposición del APIserver, se crea un balanceador de carga con nombre `<cluster_id>-apiserver` y puerto 443 accesible por red pública (la IP pública asignada es la misma que se configura en el _Kubeconfig_), y un _instance groups_ por AZ (1 o 3, según configuración de HA) con el nodo de _control-plane_ correspondiente.

El _Health Check_ del servicio se hace por SSL, pero se recomienda cambiar a HTTPS con la ruta `/healthz`.

==== Azure no-gestionado

Para la exposición del APIserver, se crea un balanceador de carga con nombre `<cluster_id>-public-lb` y puerto 6443 accesible por red pública (la IP pública asignada es la misma que resuelve la URL del _Kubeconfig_), y un _Backend pool_ con los nodos del _control-plane_.

El _Health Check_ del servicio se hace por TCP, pero se recomienda cambiar a HTTPS con la ruta `/healthz`.

==== AKS

En este caso, el APIserver se expone públicamente y con la URL indicada en el _kubeconfig_.

== Almacenamiento

=== Nodos (control-plane y workers)

A nivel de almacenamiento, se monta un único disco _root_ del que se puede definir su tipo, tamaño y encriptación (se podrá especificar una clave de encriptación previamente creada).

Ejemplo:

[source,bash]
----
type: gp3
size: 384Gi
encrypted: true
encryption_key: <key_name>
----

Estos discos se crean en la provisión inicial de los nodos, por lo que estos datos se pasan como parámetros del descriptor.

# TODO: Discos por defecto en standard y premium?

=== _StorageClass_

Durante el aprovisionamiento se disponibiliza una _StorageClass_ (default) con nombre "keos" para disco de bloques. Ésta cuenta con los parámetros _reclaimPolicy: Delete_ y _volumeBindingMode: WaitForFirstConsumer_, esto es, que el disco se creará en el momento en que un _pod_ consuma el _PersistentVolumeClaim_ correspondiente, y se eliminará al borrar el _PersistentVolume_. Los parámetros de esta _StorageClass_ se podrán personalizar en el descriptor del cluster.

Se deberá tener en cuenta que los _PersistentVolumes_ creados a partir de esta _StorageClass_ tendrán afinidad con la zona donde se han consumido.

En el aprovisionamiento se crean otras _StorageClasses_ (no default) según el provider, pero para utilizarlas, las cargas de trabajo deberán especificarlas en su despliegue.
